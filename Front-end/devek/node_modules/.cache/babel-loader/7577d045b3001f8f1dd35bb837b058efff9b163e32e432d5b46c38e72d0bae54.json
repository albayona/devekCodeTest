{"ast":null,"code":"var _jsxFileName = \"/Users/andresbayona/Documents/DevekRepo/devekCodeTest/Frontend/devek/src/contexts/ChatRoomsContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useState, useCallback } from \"react\";\nimport { io } from \"socket.io-client\";\nimport { useAuth } from \"./UserContext\";\nimport { API_HOST } from \"../hooks/UseFetch\";\nimport { useFetch } from \"../hooks/UseFetch\";\nimport { fetchAPI } from \"../components/utils/fetch\";\n\n// Define Message type\n\n// Define Messages Dictionary Type\n\n// Define the Socket Context type\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Create the context\nconst SocketContext = /*#__PURE__*/createContext(undefined);\n\n// Socket.IO server URL\nconst SOCKET_SERVER_URL = \"http://localhost:3000\"; // Change this to your backend URL\n\nexport const socket = io(SOCKET_SERVER_URL, {\n  autoConnect: false\n});\n\n// Provider Component\nexport const SocketProvider = ({\n  children\n}) => {\n  _s();\n  const [joinedRooms, setJoinedRooms] = useState([]);\n  const [availableRooms, setAvailableRooms] = useState([]);\n  const [messages, setMessages] = useState({});\n  console.log(messages);\n  const [isConnected, setIsConnected] = useState(socket.connected);\n  const [updateTriggerJoined, setUpdateTriggerJoined] = useState(true);\n  const [updateTriggerAvailable, setUpdateTriggerAvailable] = useState(true);\n  const {\n    user\n  } = useAuth();\n  const {\n    token\n  } = useAuth();\n  const paramsJoined = {\n    updateTrigger: updateTriggerJoined,\n    setUpdateTrigger: setUpdateTriggerJoined,\n    setData: setJoinedRooms,\n    token,\n    user,\n    endpoint: \"groupchats/joined/\",\n    queryParams: \"\"\n  };\n  const paramsAvailable = {\n    updateTrigger: updateTriggerAvailable,\n    setUpdateTrigger: setUpdateTriggerAvailable,\n    setData: setAvailableRooms,\n    token,\n    user,\n    endpoint: \"groupchats/available/\",\n    queryParams: \"\"\n  };\n  const [error, isLoading] = useFetch(generateRequestJoined(paramsJoined));\n  const [errorA, isLoadingA] = useFetch(generateRequestAvailable(paramsAvailable));\n  function generateRequestJoined({\n    updateTrigger,\n    setUpdateTrigger,\n    setData,\n    token,\n    user,\n    endpoint,\n    queryParams\n  }) {\n    return {\n      triggerRequest: updateTrigger && user !== null,\n      setTriggerRequest: setUpdateTrigger,\n      callback: data => {\n        setUpdateTrigger(false);\n        setData(data['joined_groupchats']);\n        for (const g of data['joined_groupchats']) {\n          socket.emit(\"join_group\", {\n            \"group\": g\n          });\n        }\n      },\n      method: \"GET\",\n      headers: {\n        \"Authorization\": `Bearer ${token}`,\n        \"Content-Type\": \"application/json\",\n        \"X-Consumer-Custom-Id\": String(user)\n      },\n      endpoint: `${API_HOST}/${endpoint}?${queryParams}`,\n      payload: null\n    };\n  }\n  function generateRequestAvailable({\n    updateTrigger,\n    setUpdateTrigger,\n    setData,\n    token,\n    user,\n    endpoint,\n    queryParams\n  }) {\n    return {\n      triggerRequest: updateTrigger && user !== null,\n      setTriggerRequest: setUpdateTrigger,\n      callback: data => {\n        setUpdateTrigger(false);\n        console.log(data);\n        setData(data['available_groupchats']);\n      },\n      method: \"GET\",\n      headers: {\n        \"Authorization\": `Bearer ${token}`,\n        \"Content-Type\": \"application/json\",\n        \"X-Consumer-Custom-Id\": String(user)\n      },\n      endpoint: `${API_HOST}/${endpoint}?${queryParams}`,\n      payload: null\n    };\n  }\n  useEffect(() => {\n    socket.connect();\n    function onConnect() {\n      socket.emit(\"join\", {\n        \"user\": user\n      });\n      setIsConnected(true);\n      console.log(\"Connected to socket:\", socket.id);\n    }\n    socket.on(\"connect\", () => {\n      onConnect();\n    });\n    function onDisconnect() {\n      setIsConnected(false);\n      console.log(\"Disconnected from socket\");\n    }\n    socket.on(\"disconnect\", () => {\n      onDisconnect();\n    });\n\n    // Listen for incoming messages and update the state\n    const onMessage = data => {\n      console.log(data);\n      const newMessage = {\n        sender: data.email,\n        date: new Date().toISOString(),\n        read: false,\n        received: true,\n        text: data.text\n      };\n      setMessages(prevMessages => ({\n        ...prevMessages,\n        [data.group]: [...(prevMessages[data.group] || []), newMessage]\n      }));\n    };\n    socket.on(\"message\", onMessage);\n    return () => {\n      socket.off(\"connect\", onConnect);\n      socket.off(\"disconnect\", onDisconnect);\n      socket.off(\"message\", onMessage);\n      socket.disconnect();\n    };\n  }, []);\n  const joinRoom = async groupchatId => {\n    try {\n      const res = fetchAPI(token, user, null, null, `${API_HOST}/groupchats/join/${groupchatId}`, 'POST');\n      const response = await fetch(`${API_HOST}/groupchats/join/${groupchatId}`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\",\n          \"X-Consumer-Custom-Id\": String(user)\n        }\n      });\n      if (!response.ok) {\n        throw new Error(\"Failed to join room\");\n      }\n      const data = await response.json();\n      setJoinedRooms(prev => [...prev, groupchatId]);\n      setAvailableRooms(prev => prev.filter(room => room !== groupchatId));\n      socket.emit(\"join_chat\", groupchatId);\n    } catch (error) {\n      console.error(\"Error joining room:\", error);\n    }\n  };\n\n  // Emit function to send messages\n  const sendMessage = useCallback(data => {\n    if (socket) {\n      socket.emit(\"message\", data);\n      const u = String(user);\n      console.log(user);\n      const newMessage = {\n        sender: u,\n        date: new Date().toISOString(),\n        read: false,\n        received: true,\n        text: data.text\n      };\n      setMessages(prevMessages => ({\n        ...prevMessages,\n        [data.group]: [...(prevMessages[data.group] || []), newMessage]\n      }));\n    }\n  }, [socket]);\n\n  // Function to retrieve messages by room\n  const getMessagesByRoom = roomID => {\n    return messages[roomID] || [];\n  };\n  return /*#__PURE__*/_jsxDEV(SocketContext.Provider, {\n    value: {\n      socket,\n      sendMessage,\n      getMessagesByRoom,\n      joinedRooms,\n      availableRooms,\n      joinRoom\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 268,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use the Socket Context\n_s(SocketProvider, \"C1RZZm7dm5dDImYKW0R0y8KIbVg=\", false, function () {\n  return [useAuth, useAuth, useFetch, useFetch];\n});\n_c = SocketProvider;\nexport const useSocket = () => {\n  _s2();\n  const context = useContext(SocketContext);\n  if (!context) {\n    throw new Error(\"useSocket must be used within a SocketProvider\");\n  }\n  return context;\n};\n_s2(useSocket, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"SocketProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","useCallback","io","useAuth","API_HOST","useFetch","fetchAPI","jsxDEV","_jsxDEV","SocketContext","undefined","SOCKET_SERVER_URL","socket","autoConnect","SocketProvider","children","_s","joinedRooms","setJoinedRooms","availableRooms","setAvailableRooms","messages","setMessages","console","log","isConnected","setIsConnected","connected","updateTriggerJoined","setUpdateTriggerJoined","updateTriggerAvailable","setUpdateTriggerAvailable","user","token","paramsJoined","updateTrigger","setUpdateTrigger","setData","endpoint","queryParams","paramsAvailable","error","isLoading","generateRequestJoined","errorA","isLoadingA","generateRequestAvailable","triggerRequest","setTriggerRequest","callback","data","g","emit","method","headers","String","payload","connect","onConnect","id","on","onDisconnect","onMessage","newMessage","sender","email","date","Date","toISOString","read","received","text","prevMessages","group","off","disconnect","joinRoom","groupchatId","res","response","fetch","ok","Error","json","prev","filter","room","sendMessage","u","getMessagesByRoom","roomID","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useSocket","_s2","context","$RefreshReg$"],"sources":["/Users/andresbayona/Documents/DevekRepo/devekCodeTest/Frontend/devek/src/contexts/ChatRoomsContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState, useCallback } from \"react\";\nimport { io, Socket } from \"socket.io-client\";\nimport { useAuth } from \"./UserContext\";\nimport { API_HOST } from \"../hooks/UseFetch\";\nimport { FetchRequest } from \"../hooks/UseFetch\";\nimport { useFetch } from \"../hooks/UseFetch\";\nimport {fetchAPI} from \"../components/utils/fetch\";\n\n// Define Message type\ninterface Message {\n  sender: string ;\n  date: string;\n  read: boolean;\n  received: boolean;\n  text: string;\n}\n\nexport interface MessageDTO {\n  group: string;\n  name: string | null;\n  email: string | null;\n  text: string;\n\n}\n\n// Define Messages Dictionary Type\ninterface MessagesDictionary {\n  [roomId: string]: Message[];\n}\n\n// Define the Socket Context type\ninterface SocketContextType {\n  socket: Socket | null;\n  sendMessage: ( data: MessageDTO) => void;\n  getMessagesByRoom: (roomId: string) => Message[];\n  joinedRooms: string[];\n  availableRooms: string[];\n  joinRoom: (groupchatId: string) => void\n}\n\n// Create the context\nconst SocketContext = createContext<SocketContextType | undefined>(undefined);\n\n// Socket.IO server URL\nconst SOCKET_SERVER_URL = \"http://localhost:3000\"; // Change this to your backend URL\n\n\ntype Request = {\n  updateTrigger: boolean;\n  setUpdateTrigger: (value: boolean) => void;\n  setData: (data: string[]) => void;\n  token: string;\n  user: string | null;\n  endpoint: string;\n  queryParams: string;\n};\n\n\n\nexport const socket = io(SOCKET_SERVER_URL, {\n  autoConnect: false\n});\n\n// Provider Component\nexport const SocketProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [joinedRooms, setJoinedRooms] = useState<string[]>([]);\n  const [availableRooms, setAvailableRooms] = useState<string[]>([]);\n  const [messages, setMessages] = useState<MessagesDictionary>({});\n\n  console.log(messages);\n\n  const [isConnected, setIsConnected] = useState<boolean>(socket.connected);\n  const [updateTriggerJoined, setUpdateTriggerJoined] = useState<boolean>(true);\n  const [updateTriggerAvailable, setUpdateTriggerAvailable] = useState<boolean>(true);\n\n  const { user } = useAuth();\n  const { token } = useAuth();\n\n\n  const paramsJoined: Request = { updateTrigger: updateTriggerJoined, setUpdateTrigger: setUpdateTriggerJoined, setData: setJoinedRooms, token, user, endpoint: \"groupchats/joined/\", queryParams: \"\" };\n  const paramsAvailable: Request = { updateTrigger: updateTriggerAvailable, setUpdateTrigger: setUpdateTriggerAvailable, setData: setAvailableRooms, token, user, endpoint: \"groupchats/available/\", queryParams: \"\" };\n\n  const [error, isLoading] = useFetch(generateRequestJoined(paramsJoined));\n  const [errorA, isLoadingA] = useFetch(generateRequestAvailable(paramsAvailable));\n\n  function generateRequestJoined({\n    updateTrigger,\n    setUpdateTrigger,\n    setData,\n    token,\n    user,\n    endpoint,\n    queryParams,\n  }: Request) {\n    return {\n      triggerRequest: updateTrigger && user !== null,\n      setTriggerRequest: setUpdateTrigger,\n      callback: (data: any) => {\n        setUpdateTrigger(false);\n        setData(data['joined_groupchats']);\n\n        for (const g of data['joined_groupchats']) {\n          socket.emit(\"join_group\", {\"group\": g} );\n        }\n\n      },\n      method: \"GET\",\n      headers: {\n        \"Authorization\": `Bearer ${token}`,\n        \"Content-Type\": \"application/json\",\n        \"X-Consumer-Custom-Id\": String(user),\n      },\n\n      endpoint: `${API_HOST}/${endpoint}?${queryParams}`,\n      payload: null,\n    };\n  }\n\n\n  function generateRequestAvailable({\n    updateTrigger,\n    setUpdateTrigger,\n    setData,\n    token,\n    user,\n    endpoint,\n    queryParams,\n  }: Request) {\n    return {\n      triggerRequest: updateTrigger && user !== null,\n      setTriggerRequest: setUpdateTrigger,\n      callback: (data: any) => {\n        setUpdateTrigger(false);\n        console.log(data);\n        setData(data['available_groupchats']);\n      },\n      method: \"GET\",\n      headers: {\n        \"Authorization\": `Bearer ${token}`,\n        \"Content-Type\": \"application/json\",\n        \"X-Consumer-Custom-Id\": String(user),\n      },\n\n      endpoint: `${API_HOST}/${endpoint}?${queryParams}`,\n      payload: null,\n    };\n  }\n\n\n  useEffect(() => {\n\n    socket.connect();\n    function onConnect() {\n      socket.emit(\"join\", {\"user\": user});\n      setIsConnected(true);\n      console.log(\"Connected to socket:\", socket.id);\n    }\n\n    socket.on(\"connect\", () => {\n      onConnect();\n    });\n\n    function onDisconnect() {\n      setIsConnected(false);\n      console.log(\"Disconnected from socket\");\n    }\n\n    socket.on(\"disconnect\", () => {\n      onDisconnect();\n\n\n    });\n\n    // Listen for incoming messages and update the state\n    const onMessage = (data: {group: string,  name: string; email: string , text: string}) => {\n        console.log(data);\n\n      const newMessage: Message = {\n        sender: data.email,\n        date: new Date().toISOString(),\n        read: false,\n        received: true,\n        text: data.text,\n      };\n\n      setMessages((prevMessages) => ({\n        ...prevMessages,\n        [data.group]: [...(prevMessages[data.group] || []), newMessage],\n      }));\n    };\n\n    socket.on(\"message\", onMessage);\n\n\n\n    return () => {\n      socket.off(\"connect\", onConnect);\n      socket.off(\"disconnect\", onDisconnect);\n      socket.off(\"message\", onMessage);\n      socket.disconnect();\n    };\n  }, []);\n\n\n\n  const joinRoom = async (groupchatId: string) => {\n    try {\n\n      const res = fetchAPI(token, user, null, null, `${API_HOST}/groupchats/join/${groupchatId}`, 'POST');\n\n      const response = await fetch(`${API_HOST}/groupchats/join/${groupchatId}`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\",\n          \"X-Consumer-Custom-Id\": String(user),\n        },\n      });\n  \n      if (!response.ok) {\n        throw new Error(\"Failed to join room\");\n      }\n  \n      const data = await response.json();\n  \n      setJoinedRooms((prev) => [...prev, groupchatId]);\n      setAvailableRooms((prev) => prev.filter((room) => room !== groupchatId));\n  \n      socket.emit(\"join_chat\", groupchatId);\n    } catch (error) {\n      console.error(\"Error joining room:\", error);\n    }\n  };\n\n\n\n\n  // Emit function to send messages\n  const sendMessage = useCallback((data: MessageDTO) => {\n    if (socket) {\n      socket.emit(\"message\", data);\n\n      const u: string = String(user);\n      console.log(user);\n\n      const newMessage: Message = {\n        sender: u,\n        date: new Date().toISOString(),\n        read: false,\n        received: true,\n        text: data.text,\n      };\n\n      setMessages((prevMessages) => ({\n        ...prevMessages,\n        [data.group]: [...(prevMessages[data.group] || []), newMessage],\n      }));\n    }\n  }, [socket]);\n\n  // Function to retrieve messages by room\n  const getMessagesByRoom = (roomID: string): Message[] => {\n\n    return messages[roomID] || [];\n  };\n\n  return (\n    <SocketContext.Provider value={{ socket, sendMessage, getMessagesByRoom, joinedRooms, availableRooms, joinRoom }}>\n      {children}\n    </SocketContext.Provider>\n  );\n};\n\n// Custom hook to use the Socket Context\nexport const useSocket = () => {\n  const context = useContext(SocketContext);\n  if (!context) {\n    throw new Error(\"useSocket must be used within a SocketProvider\");\n  }\n  return context;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}