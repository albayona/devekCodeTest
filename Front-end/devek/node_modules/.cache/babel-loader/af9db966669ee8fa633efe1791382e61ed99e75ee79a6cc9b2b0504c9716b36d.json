{"ast":null,"code":"var _jsxFileName = \"/Users/andresbayona/Documents/DevekRepo/devekCodeTest/Frontend/devek/src/contexts/ChatRoomsContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useState, useCallback } from \"react\";\nimport { io } from \"socket.io-client\";\nimport { useAuth } from \"./UserContext\";\nimport { API_HOST } from \"../hooks/UseFetch\";\nimport { useFetch } from \"../hooks/UseFetch\";\nimport { fetchAPI } from \"../components/utils/fetch\";\n\n// Define Message type\n\n// Define Messages Dictionary Type\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Create the context\nconst SocketContext = /*#__PURE__*/createContext(undefined);\n\n// Socket.IO server URL\nconst SOCKET_SERVER_URL = \"http://localhost:3000\"; // Change this to your backend URL\n\nexport const socket = io(SOCKET_SERVER_URL, {\n  autoConnect: false\n});\n\n// Provider Component\nexport const SocketProvider = ({\n  children\n}) => {\n  _s();\n  const [joinedRooms, setJoinedRooms] = useState([]);\n  const [availableRooms, setAvailableRooms] = useState([]);\n  const [messages, setMessages] = useState({});\n  const [notificationCount, setNotificationCount] = useState({});\n  console.log(messages);\n  const [isConnected, setIsConnected] = useState(socket.connected);\n  const [updateTriggerJoined, setUpdateTriggerJoined] = useState(true);\n  const [updateTriggerAvailable, setUpdateTriggerAvailable] = useState(true);\n  const {\n    user,\n    logOut,\n    token\n  } = useAuth();\n  const paramsJoined = {\n    updateTrigger: updateTriggerJoined,\n    setUpdateTrigger: setUpdateTriggerJoined,\n    setData: setJoinedRooms,\n    token,\n    user,\n    endpoint: \"groupchats/joined/\",\n    queryParams: \"\"\n  };\n  const paramsAvailable = {\n    updateTrigger: updateTriggerAvailable,\n    setUpdateTrigger: setUpdateTriggerAvailable,\n    setData: setAvailableRooms,\n    token,\n    user,\n    endpoint: \"groupchats/available/\",\n    queryParams: \"\"\n  };\n  const [error, isLoading] = useFetch(generateRequestJoined(paramsJoined));\n  const [errorA, isLoadingA] = useFetch(generateRequestAvailable(paramsAvailable));\n  useEffect(() => {\n    socket.connect();\n    function onConnect() {\n      socket.emit(\"join\", {\n        \"user\": user\n      });\n      setIsConnected(true);\n      console.log(\"Connected to socket:\", socket.id);\n    }\n    socket.on(\"connect\", () => {\n      onConnect();\n    });\n    function onDisconnect() {\n      setIsConnected(false);\n      console.log(\"Disconnected from socket\");\n    }\n    socket.on(\"disconnect\", () => {\n      onDisconnect();\n    });\n\n    // Listen for incoming messages and update the state\n    const onMessage = data => {\n      console.log(data);\n      const newMessage = {\n        sender: data.email,\n        date: new Date().toISOString(),\n        read: false,\n        received: true,\n        text: data.text\n      };\n      setMessages(prevMessages => ({\n        ...prevMessages,\n        [data.group]: [...(prevMessages[data.group] || []), newMessage]\n      }));\n      setNotificationCount(prev => ({\n        ...prev,\n        // Ensure previous state is spread properly\n        [data.group]: prev[data.group] + 1 // Reset count for the specified room\n      }));\n    };\n    socket.on(\"message\", onMessage);\n    return () => {\n      socket.off(\"connect\", onConnect);\n      socket.off(\"disconnect\", onDisconnect);\n      socket.off(\"message\", onMessage);\n      socket.disconnect();\n    };\n  }, []);\n  useSocketReconnect(socket, isConnected);\n  const joinRoom = async groupchatId => {\n    try {\n      await fetchAPI(token, user, null, logOut, `${API_HOST}/groupchats/join/${groupchatId}`, 'POST');\n      setJoinedRooms(prev => [...prev, groupchatId]);\n      setAvailableRooms(prev => prev.filter(room => room !== groupchatId));\n      socket.emit(\"join_chat\", groupchatId);\n    } catch (error) {\n      console.error(\"Error joining room:\", error);\n    }\n  };\n  const leaveRoom = async groupchatId => {\n    try {\n      await fetchAPI(token, user, null, logOut, `${API_HOST}/groupchats/leave/${groupchatId}`, 'POST');\n      setJoinedRooms(prev => prev.filter(room => room !== groupchatId)); // Remove from joined rooms\n      setAvailableRooms(prev => [...prev, groupchatId]); // Add back to available rooms\n\n      socket.emit(\"leave_chat\", groupchatId);\n    } catch (error) {\n      console.error(\"Error leaving room:\", error);\n    }\n  };\n  const lastMessage = room => {\n    var _messages$room;\n    return (_messages$room = messages[room]) !== null && _messages$room !== void 0 && _messages$room.length ? messages[room][messages[room].length - 1].text : \"\";\n  };\n  const readMessages = room => {\n    setNotificationCount(prev => ({\n      ...prev,\n      // Ensure previous state is spread properly\n      [room]: 0 // Reset count for the specified room\n    }));\n  };\n  const getNotificationCount = room => {\n    return notificationCount[room] || 0;\n  };\n\n  // Emit function to send messages\n  const sendMessage = useCallback(data => {\n    if (socket) {\n      socket.emit(\"message\", data);\n      const u = String(user);\n      console.log(user);\n      const newMessage = {\n        sender: u,\n        date: new Date().toISOString(),\n        read: false,\n        received: true,\n        text: data.text\n      };\n      setMessages(prevMessages => ({\n        ...prevMessages,\n        [data.group]: [...(prevMessages[data.group] || []), newMessage]\n      }));\n    }\n  }, [socket]);\n\n  // Function to retrieve messages by room\n  const getMessagesByRoom = roomID => {\n    return messages[roomID] || [];\n  };\n  return /*#__PURE__*/_jsxDEV(SocketContext.Provider, {\n    value: {\n      socket,\n      sendMessage,\n      getMessagesByRoom,\n      joinedRooms,\n      availableRooms,\n      joinRoom,\n      leaveRoom,\n      lastMessage,\n      getNotificationCount,\n      readMessages\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 245,\n    columnNumber: 9\n  }, this);\n};\n\n// Custom hook to use the Socket Context\n_s(SocketProvider, \"Kg1BTO4nFX1ezXVLKlfAVxdUWBE=\", false, function () {\n  return [useAuth, useFetch, useFetch, useSocketReconnect];\n});\n_c = SocketProvider;\nexport const useRoom = () => {\n  _s2();\n  const context = useContext(SocketContext);\n  if (!context) {\n    throw new Error(\"useSocket must be used within a SocketProvider\");\n  }\n  return context;\n};\n_s2(useRoom, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nfunction generateRequestJoined({\n  updateTrigger,\n  setUpdateTrigger,\n  setData,\n  setNotificationCount,\n  token,\n  user,\n  endpoint,\n  queryParams\n}) {\n  return {\n    triggerRequest: updateTrigger && user !== null,\n    setTriggerRequest: setUpdateTrigger,\n    callback: data => {\n      setUpdateTrigger(false);\n      setData(data['joined_groupchats']);\n      for (const g of data['joined_groupchats']) {\n        socket.emit(\"join_group\", {\n          \"group\": g\n        });\n      }\n    },\n    method: \"GET\",\n    headers: {\n      \"Authorization\": `Bearer ${token}`,\n      \"Content-Type\": \"application/json\",\n      \"X-Consumer-Custom-Id\": String(user)\n    },\n    endpoint: `${API_HOST}/${endpoint}?${queryParams}`,\n    payload: null\n  };\n}\nfunction generateRequestAvailable({\n  updateTrigger,\n  setUpdateTrigger,\n  setData,\n  token,\n  user,\n  endpoint,\n  queryParams\n}) {\n  return {\n    triggerRequest: updateTrigger && user !== null,\n    setTriggerRequest: setUpdateTrigger,\n    callback: data => {\n      setUpdateTrigger(false);\n      console.log(data);\n      setData(data['available_groupchats']);\n    },\n    method: \"GET\",\n    headers: {\n      \"Authorization\": `Bearer ${token}`,\n      \"Content-Type\": \"application/json\",\n      \"X-Consumer-Custom-Id\": String(user)\n    },\n    endpoint: `${API_HOST}/${endpoint}?${queryParams}`,\n    payload: null\n  };\n}\nconst useSocketReconnect = (socket, isConnected) => {\n  _s3();\n  useEffect(() => {\n    if (!isConnected && navigator.onLine) {\n      console.log(\"Socket disconnected. Attempting to reconnect...\");\n      socket.connect();\n    }\n\n    // Listen for when internet connection is restored\n    const handleOnline = () => {\n      if (!isConnected) {\n        console.log(\"Internet restored, reconnecting socket...\");\n        socket.connect();\n      }\n    };\n    window.addEventListener(\"online\", handleOnline);\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n    };\n  }, [isConnected, socket]);\n};\n_s3(useSocketReconnect, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\nvar _c;\n$RefreshReg$(_c, \"SocketProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","useCallback","io","useAuth","API_HOST","useFetch","fetchAPI","jsxDEV","_jsxDEV","SocketContext","undefined","SOCKET_SERVER_URL","socket","autoConnect","SocketProvider","children","_s","joinedRooms","setJoinedRooms","availableRooms","setAvailableRooms","messages","setMessages","notificationCount","setNotificationCount","console","log","isConnected","setIsConnected","connected","updateTriggerJoined","setUpdateTriggerJoined","updateTriggerAvailable","setUpdateTriggerAvailable","user","logOut","token","paramsJoined","updateTrigger","setUpdateTrigger","setData","endpoint","queryParams","paramsAvailable","error","isLoading","generateRequestJoined","errorA","isLoadingA","generateRequestAvailable","connect","onConnect","emit","id","on","onDisconnect","onMessage","data","newMessage","sender","email","date","Date","toISOString","read","received","text","prevMessages","group","prev","off","disconnect","useSocketReconnect","joinRoom","groupchatId","filter","room","leaveRoom","lastMessage","_messages$room","length","readMessages","getNotificationCount","sendMessage","u","String","getMessagesByRoom","roomID","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useRoom","_s2","context","Error","triggerRequest","setTriggerRequest","callback","g","method","headers","payload","_s3","navigator","onLine","handleOnline","window","addEventListener","removeEventListener","$RefreshReg$"],"sources":["/Users/andresbayona/Documents/DevekRepo/devekCodeTest/Frontend/devek/src/contexts/ChatRoomsContext.tsx"],"sourcesContent":["import React, {createContext, useContext, useEffect, useState, useCallback} from \"react\";\nimport {io, Socket} from \"socket.io-client\";\nimport {useAuth} from \"./UserContext\";\nimport {API_HOST} from \"../hooks/UseFetch\";\nimport {FetchRequest} from \"../hooks/UseFetch\";\nimport {useFetch} from \"../hooks/UseFetch\";\nimport {fetchAPI} from \"../components/utils/fetch\";\n\n// Define Message type\ninterface Message {\n    sender: string;\n    date: string;\n    read: boolean;\n    received: boolean;\n    text: string;\n}\n\nexport interface MessageDTO {\n    group: string;\n    name: string | null;\n    email: string | null;\n    text: string;\n\n}\n\n// Define Messages Dictionary Type\ninterface MessagesDictionary {\n    [roomId: string]: Message[];\n}\n\n\n\n\ninterface SocketContextType {\n    socket: Socket | null;\n    sendMessage: (data: MessageDTO) => void;\n    getMessagesByRoom: (roomId: string) => Message[];\n    joinedRooms: string[];\n    availableRooms: string[];\n    joinRoom: (groupchatId: string) => void\n    leaveRoom: (groupchatId: string) => void\n    lastMessage: (groupchatId: string) => string,\n    getNotificationCount: (room: string) => number;\n    readMessages: (room: string) => void;\n}\n\n// Create the context\nconst SocketContext = createContext<SocketContextType | undefined>(undefined);\n\n// Socket.IO server URL\nconst SOCKET_SERVER_URL = \"http://localhost:3000\"; // Change this to your backend URL\n\n\ntype Request = {\n    updateTrigger: boolean;\n    setUpdateTrigger: (value: boolean) => void;\n    setData: (data: string[]) => void;\n    token: string;\n    user: string | null;\n    endpoint: string;\n    queryParams: string;\n};\n\n\nexport const socket = io(SOCKET_SERVER_URL, {\n    autoConnect: false\n});\n\n// Provider Component\nexport const SocketProvider: React.FC<{ children: React.ReactNode }> = ({children}) => {\n    const [joinedRooms, setJoinedRooms] = useState<string[]>([]);\n    const [availableRooms, setAvailableRooms] = useState<string[]>([]);\n    const [messages, setMessages] = useState<MessagesDictionary>({});\n    const [notificationCount, setNotificationCount] = useState<Record<string, number>>({});\n\n    console.log(messages);\n\n    const [isConnected, setIsConnected] = useState<boolean>(socket.connected);\n    const [updateTriggerJoined, setUpdateTriggerJoined] = useState<boolean>(true);\n    const [updateTriggerAvailable, setUpdateTriggerAvailable] = useState<boolean>(true);\n\n    const {user, logOut, token} = useAuth();\n\n\n    const paramsJoined: Request = {\n        updateTrigger: updateTriggerJoined,\n        setUpdateTrigger: setUpdateTriggerJoined,\n        setData: setJoinedRooms,\n        token,\n        user,\n        endpoint: \"groupchats/joined/\",\n        queryParams: \"\"\n    };\n    const paramsAvailable: Request = {\n        updateTrigger: updateTriggerAvailable,\n        setUpdateTrigger: setUpdateTriggerAvailable,\n        setData: setAvailableRooms,\n        token,\n        user,\n        endpoint: \"groupchats/available/\",\n        queryParams: \"\"\n    };\n\n    const [error, isLoading] = useFetch(generateRequestJoined(paramsJoined));\n    const [errorA, isLoadingA] = useFetch(generateRequestAvailable(paramsAvailable));\n\n\n\n    useEffect(() => {\n\n        socket.connect();\n\n        function onConnect() {\n            socket.emit(\"join\", {\"user\": user});\n            setIsConnected(true);\n            console.log(\"Connected to socket:\", socket.id);\n        }\n\n        socket.on(\"connect\", () => {\n            onConnect();\n        });\n\n        function onDisconnect() {\n            setIsConnected(false);\n            console.log(\"Disconnected from socket\");\n        }\n\n        socket.on(\"disconnect\", () => {\n            onDisconnect();\n\n\n        });\n\n        // Listen for incoming messages and update the state\n        const onMessage = (data: { group: string, name: string; email: string, text: string }) => {\n            console.log(data);\n\n            const newMessage: Message = {\n                sender: data.email,\n                date: new Date().toISOString(),\n                read: false,\n                received: true,\n                text: data.text,\n            };\n\n            setMessages((prevMessages) => ({\n                ...prevMessages,\n                [data.group]: [...(prevMessages[data.group] || []), newMessage],\n            }));\n\n            setNotificationCount((prev) => ({\n                ...prev, // Ensure previous state is spread properly\n                [data.group]: prev[data.group] + 1, // Reset count for the specified room\n            }));\n        };\n\n        socket.on(\"message\", onMessage);\n\n\n        return () => {\n            socket.off(\"connect\", onConnect);\n            socket.off(\"disconnect\", onDisconnect);\n            socket.off(\"message\", onMessage);\n            socket.disconnect();\n        };\n    }, []);\n\n\n    useSocketReconnect(socket, isConnected);\n\n\n    const joinRoom = async (groupchatId: string) => {\n        try {\n\n            await fetchAPI(token, user, null, logOut, `${API_HOST}/groupchats/join/${groupchatId}`, 'POST');\n\n            setJoinedRooms((prev) => [...prev, groupchatId]);\n            setAvailableRooms((prev) => prev.filter((room) => room !== groupchatId));\n\n            socket.emit(\"join_chat\", groupchatId);\n        } catch (error) {\n            console.error(\"Error joining room:\", error);\n        }\n    };\n\n    const leaveRoom = async (groupchatId: string) => {\n        try {\n            await fetchAPI(token, user, null, logOut, `${API_HOST}/groupchats/leave/${groupchatId}`, 'POST');\n\n            setJoinedRooms((prev) => prev.filter((room) => room !== groupchatId)); // Remove from joined rooms\n            setAvailableRooms((prev) => [...prev, groupchatId]); // Add back to available rooms\n\n            socket.emit(\"leave_chat\", groupchatId);\n        } catch (error) {\n            console.error(\"Error leaving room:\", error);\n        }\n    };\n\n    const lastMessage = (room: string) => {\n        return messages[room]?.length ? messages[room][messages[room].length - 1].text : \"\";\n    };\n\n    const readMessages = (room: string) => {\n        setNotificationCount((prev) => ({\n            ...prev, // Ensure previous state is spread properly\n            [room]: 0, // Reset count for the specified room\n        }));\n    };\n    const getNotificationCount = (room: string) => {\n        return notificationCount[room] || 0;\n    }\n\n\n\n    // Emit function to send messages\n    const sendMessage = useCallback((data: MessageDTO) => {\n        if (socket) {\n            socket.emit(\"message\", data);\n\n            const u: string = String(user);\n            console.log(user);\n\n            const newMessage: Message = {\n                sender: u,\n                date: new Date().toISOString(),\n                read: false,\n                received: true,\n                text: data.text,\n            };\n\n            setMessages((prevMessages) => ({\n                ...prevMessages,\n                [data.group]: [...(prevMessages[data.group] || []), newMessage],\n            }));\n        }\n    }, [socket]);\n\n    // Function to retrieve messages by room\n    const getMessagesByRoom = (roomID: string): Message[] => {\n\n        return messages[roomID] || [];\n    };\n\n    return (\n        <SocketContext.Provider value={{socket, sendMessage, getMessagesByRoom, joinedRooms, availableRooms, joinRoom, leaveRoom, lastMessage, getNotificationCount, readMessages}}>\n            {children}\n        </SocketContext.Provider>\n    );\n};\n\n// Custom hook to use the Socket Context\nexport const useRoom = () => {\n    const context = useContext(SocketContext);\n    if (!context) {\n        throw new Error(\"useSocket must be used within a SocketProvider\");\n    }\n    return context;\n};\n\n\nfunction generateRequestJoined({\n                                 updateTrigger,\n                                 setUpdateTrigger,\n                                 setData,\n    setNotificationCount,\n                                 token,\n                                 user,\n                                 endpoint,\n                                 queryParams,\n                               }: Request) {\n  return {\n    triggerRequest: updateTrigger && user !== null,\n    setTriggerRequest: setUpdateTrigger,\n    callback: (data: any) => {\n      setUpdateTrigger(false);\n      setData(data['joined_groupchats']);\n\n     \n\n      for (const g of data['joined_groupchats']) {\n        socket.emit(\"join_group\", {\"group\": g});\n      }\n\n    },\n    method: \"GET\",\n    headers: {\n      \"Authorization\": `Bearer ${token}`,\n      \"Content-Type\": \"application/json\",\n      \"X-Consumer-Custom-Id\": String(user),\n    },\n\n    endpoint: `${API_HOST}/${endpoint}?${queryParams}`,\n    payload: null,\n  };\n}\n\n\nfunction generateRequestAvailable({\n                                    updateTrigger,\n                                    setUpdateTrigger,\n                                    setData,\n                                    token,\n                                    user,\n                                    endpoint,\n                                    queryParams,\n                                  }: Request) {\n  return {\n    triggerRequest: updateTrigger && user !== null,\n    setTriggerRequest: setUpdateTrigger,\n    callback: (data: any) => {\n      setUpdateTrigger(false);\n      console.log(data);\n      setData(data['available_groupchats']);\n    },\n    method: \"GET\",\n    headers: {\n      \"Authorization\": `Bearer ${token}`,\n      \"Content-Type\": \"application/json\",\n      \"X-Consumer-Custom-Id\": String(user),\n    },\n\n    endpoint: `${API_HOST}/${endpoint}?${queryParams}`,\n    payload: null,\n  };\n}\n\n\nconst useSocketReconnect = (socket: any, isConnected: boolean) => {\n  useEffect(() => {\n    if (!isConnected && navigator.onLine) {\n      console.log(\"Socket disconnected. Attempting to reconnect...\");\n      socket.connect();\n    }\n\n    // Listen for when internet connection is restored\n    const handleOnline = () => {\n      if (!isConnected) {\n        console.log(\"Internet restored, reconnecting socket...\");\n        socket.connect();\n      }\n    };\n\n    window.addEventListener(\"online\", handleOnline);\n\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n    };\n  }, [isConnected, socket]);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}